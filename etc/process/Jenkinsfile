#!/usr/bin/env groovy
//
// The main Jenkinsfile for FIBO, defining the Build/Publish/Test/Deploy process that is
// executed for each push into the repository.
//
// Note that this file is in the so called "Declarative Pipeline" syntax
//
// See https://jenkins.io/doc/book/pipeline/jenkinsfile/
//

//
// Send notifications to the ontology-builder slack channel
//
def slackNotifier(String productName, String buildResult) {

  def message="Product \"${productName} was built and had status ${buildResult}: <${env.BUILD_URL}|Open ${env.JOB_NAME} ${env.BUILD_NUMBER}>"

  if (buildResult == "SUCCESS") {
    echo "Product ${productName} was built successfully"
    slackSend color: "good", message: message
  }
  else if (buildResult == "FAILURE") {
    echo "ERROR: ${productName} Product Build failed"
    slackSend color: "danger", message: message
  }
  else if (buildResult == "UNSTABLE") {
    echo "WARNING: ${productName} Product Build is unstable"
    slackSend color: "warning", message: message
  }
  else {
    echo "ERROR: ${productName} Product Build failed with buildResult=${buildResult}"
    slackSend color: "danger", message: message
  }
}

pipeline {

  agent none

  environment {
    ONTPUB_FAMILY       = 'fibo'
    ONTPUB_SPEC_HOST    = 'spec.edmcouncil.org'
    ONTPUB_IS_DARK_MODE = 0
    ONTPUB_IMAGE        = 'edmcouncil/ontology-publisher:latest'
    LC_ALL              = 'en_US.UTF-8'
    LANG                = 'en_US.UTF-8'
    LANGUAGE            = 'en_US.UTF-8'
  }

  options {

    buildDiscarder(
      logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '5')
    )
    //
    // We let each stage running on each jenkins slave / agent decide what to check out or not
    //
    skipDefaultCheckout()
    //
    // Skip stages once the build status has gone to UNSTABLE.
    //
    skipStagesAfterUnstable()
    //
    // There must be SOME limit, if it hangs or whatever then that's a bug and therefore cancel the job.
    //
    timeout(time: 23, unit: 'HOURS')
    //
    // Prepend all console output generated by the Pipeline run with the time at which the line was emitted
    //
    //timestamps()
    ansiColor('xterm')
  }

  stages {

    stage ('Hygiene Tests') {
      agent {
        docker {
          image env.ONTPUB_IMAGE
          label 'docker'
          alwaysPull true
          args  "\
            --network none \
            --name ontology-publisher-${env.BUILD_NUMBER}-hygiene \
          "
        }
      }
      steps {
        dir('input') {
          dir('fibo') {
//          checkout scm
            checkout([
                    $class: 'GitSCM',
                    branches: scm.branches,
                    doGenerateSubmoduleConfigurations: false,
                    extensions: [
                            [$class: 'LocalBranch', localBranch: '**'],
                            [$class: 'CheckoutOption', timeout: 1],
                            [$class: 'CloneOption', depth: 2, noTags: false, reference: '/var/lib/git/fibo', shallow: true, timeout: 1],
                            [$class: 'AuthorInChangelog'],
                            [$class: 'PruneStaleBranch'],
                            [$class: 'IgnoreNotifyCommit']
                    ],
                    submoduleCfg: [],
                    userRemoteConfigs: [
                            [credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877', url: 'https://github.com/edmcouncil/fibo.git']
                    ]
            ])
          }
          dir('LCC') { git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins' }
        }
        //
        // Execute the publish script
        //
        sh "/publisher/publish.sh hygiene"
      }
      post {
        success {
          slackSend color: 'good', message: "${env.JOB_NAME} - #${env.BUILD_NUMBER} Hygiene Test was successful (<${env.BUILD_URL}|Open>)"
        }
        failure {
          echo "ERROR: Hygiene Test failed for job ${env.BUILD_NUMBER}"
          slackSend color: 'bad', message: "${env.JOB_NAME} - #${env.BUILD_NUMBER} Hygiene Test failed (<${env.BUILD_URL}|Open>)"
        }
      }
    }

    stage('Build Product Ontology') {
      agent {
        docker {
          image env.ONTPUB_IMAGE
          label 'docker'
          alwaysPull true
          args  "\
            --network none \
            --name ontology-publisher-${env.BUILD_NUMBER}-ontology \
          "
        }
      }
      steps {
        dir('input') {
          dir('fibo') {
//          checkout scm
            checkout([
                    $class: 'GitSCM',
                    branches: scm.branches,
                    doGenerateSubmoduleConfigurations: false,
                    extensions: [
                            [$class: 'LocalBranch', localBranch: '**'],
                            [$class: 'CheckoutOption', timeout: 1],
                            [$class: 'CloneOption', depth: 2, noTags: false, reference: '/var/lib/git/fibo', shallow: true, timeout: 1],
                            [$class: 'AuthorInChangelog'],
                            [$class: 'PruneStaleBranch'],
                            [$class: 'IgnoreNotifyCommit']
                    ],
                    submoduleCfg: [],
                    userRemoteConfigs: [
                            [credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877', url: 'https://github.com/edmcouncil/fibo.git']
                    ]
            ])
          }
          dir('LCC') { git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins' }
        }
        //
        // Execute the publish script
        //
        sh "/publisher/publish.sh ontology"
      }
      post {
        always {
          archiveArtifacts artifacts: 'output/fibo/ontology/**/*.log', fingerprint: true
          script {
            slackNotifier(productName: 'Ontology', buildResult: currentBuild.currentResult)
          }
        }
      }
    } // end of stage 'Build Product Ontology'

    stage('Build Other Products') {
      parallel {
        stage("Build Widoco") {
          agent {
            docker {
              image env.ONTPUB_IMAGE
              label 'docker'
              alwaysPull true
              args  "\
                --network none \
                --name ontology-publisher-${env.BUILD_NUMBER}-widoco \
              "
            }
          }
          steps {
            dir('input') {
              dir('fibo') {
//          checkout scm
                checkout([
                        $class: 'GitSCM',
                        branches: scm.branches,
                        doGenerateSubmoduleConfigurations: false,
                        extensions: [
                                [$class: 'LocalBranch', localBranch: '**'],
                                [$class: 'CheckoutOption', timeout: 1],
                                [$class: 'CloneOption', depth: 2, noTags: false, reference: '/var/lib/git/fibo', shallow: true, timeout: 1],
                                [$class: 'AuthorInChangelog'],
                                [$class: 'PruneStaleBranch'],
                                [$class: 'IgnoreNotifyCommit']
                        ],
                        submoduleCfg: [],
                        userRemoteConfigs: [
                                [credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877', url: 'https://github.com/edmcouncil/fibo.git']
                        ]
                ])
              }
              dir('LCC') { git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins' }
            }
            unstash 'output-ontology'
            sh "/publisher/publish.sh widoco"
          }
          post {
            success {
              stash name: 'output-widoco', includes: 'output/fibo/widoco/**'
            }
            always {
              archiveArtifacts artifacts: 'output/fibo/widoco/**/*.log', fingerprint: true
              script {
                slackNotifier(productName: 'Widoco', buildResult: currentBuild.currentResult)
              }
            }
          }
        }
        stage("Build Fibopedia") {
          agent {
            docker {
              image env.ONTPUB_IMAGE
              label 'docker'
              alwaysPull true
              args  "\
                --network none \
                --name ontology-publisher-${env.BUILD_NUMBER}-fibopedia \
              "
            }
          }
          steps {
            dir('input') {
              dir('fibo') {
//          checkout scm
                checkout([
                        $class: 'GitSCM',
                        branches: scm.branches,
                        doGenerateSubmoduleConfigurations: false,
                        extensions: [
                                [$class: 'LocalBranch', localBranch: '**'],
                                [$class: 'CheckoutOption', timeout: 1],
                                [$class: 'CloneOption', depth: 2, noTags: false, reference: '/var/lib/git/fibo', shallow: true, timeout: 1],
                                [$class: 'AuthorInChangelog'],
                                [$class: 'PruneStaleBranch'],
                                [$class: 'IgnoreNotifyCommit']
                        ],
                        submoduleCfg: [],
                        userRemoteConfigs: [
                                [credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877', url: 'https://github.com/edmcouncil/fibo.git']
                        ]
                ])
              }
              dir('LCC') { git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins' }
            }
            sh "/publisher/publish.sh fibopedia"
          }
          post {
            success {
              stash name: 'output-fibopedia', includes: 'output/fibo/fibopedia/**'
            }
            always {
              archiveArtifacts artifacts: 'output/fibo/fibopedia/**/*.log', fingerprint: true
              script {
                slackNotifier(productName: 'FIBOpedia', buildResult: currentBuild.currentResult)
              }
            }
          }
        }
        stage("Build Glossary") {
          agent {
            docker {
              image env.ONTPUB_IMAGE
              label 'docker'
              alwaysPull true
              args  "\
                --network none \
                --name ontology-publisher-${env.BUILD_NUMBER}-glossary \
              "
            }
          }
          steps {
            dir('input') {
              dir('fibo') {
//          checkout scm
                checkout([
                        $class: 'GitSCM',
                        branches: scm.branches,
                        doGenerateSubmoduleConfigurations: false,
                        extensions: [
                                [$class: 'LocalBranch', localBranch: '**'],
                                [$class: 'CheckoutOption', timeout: 1],
                                [$class: 'CloneOption', depth: 2, noTags: false, reference: '/var/lib/git/fibo', shallow: true, timeout: 1],
                                [$class: 'AuthorInChangelog'],
                                [$class: 'PruneStaleBranch'],
                                [$class: 'IgnoreNotifyCommit']
                        ],
                        submoduleCfg: [],
                        userRemoteConfigs: [
                                [credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877', url: 'https://github.com/edmcouncil/fibo.git']
                        ]
                ])
              }
              dir('LCC') { git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins' }
            }
            unstash 'output-ontology'
            sh "/publisher/publish.sh glossary"
          }
          post {
            success {
              stash name: 'output-glossary', includes: 'output/fibo/glossary/**'
            }
            always {
              archiveArtifacts artifacts: 'output/fibo/glossary/**/*.log', fingerprint: true
              script {
                slackNotifier(productName: 'GLossary', buildResult: currentBuild.currentResult)
              }
            }
          }
        }
        stage("Build Vocabulary") {
          agent {
            docker {
              image env.ONTPUB_IMAGE
              label 'docker'
              alwaysPull true
              args  "\
                --network none \
                --name ontology-publisher-${env.BUILD_NUMBER}-vocabulary \
              "
            }
          }
          steps {
            dir('input') {
              dir('fibo') {
//          checkout scm
                checkout([
                        $class: 'GitSCM',
                        branches: scm.branches,
                        doGenerateSubmoduleConfigurations: false,
                        extensions: [
                                [$class: 'LocalBranch', localBranch: '**'],
                                [$class: 'CheckoutOption', timeout: 1],
                                [$class: 'CloneOption', depth: 2, noTags: false, reference: '/var/lib/git/fibo', shallow: true, timeout: 1],
                                [$class: 'AuthorInChangelog'],
                                [$class: 'PruneStaleBranch'],
                                [$class: 'IgnoreNotifyCommit']
                        ],
                        submoduleCfg: [],
                        userRemoteConfigs: [
                                [credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877', url: 'https://github.com/edmcouncil/fibo.git']
                        ]
                ])
              }
              dir('LCC') { git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins' }
            }
            unstash 'output-ontology'
            sh "/publisher/publish.sh vocabulary"
          }
          post {
            success {
              stash name: 'output-vocabulary', includes: 'output/fibo/vocabulary/**'
            }
            always {
              archiveArtifacts artifacts: 'output/fibo/vocabulary/**/*.log', fingerprint: true
              script {
                slackNotifier(productName: 'Vocabulary', buildResult: currentBuild.currentResult)
              }
            }
          }
        }
        stage("Build Datadictionary") {
          agent {
            docker {
              image env.ONTPUB_IMAGE
              label 'docker'
              alwaysPull true
              args  "\
                --network none \
                --name ontology-publisher-${env.BUILD_NUMBER}-datadictionary \
              "
            }
          }
          steps {
            dir('input') {
              dir('fibo') {
//          checkout scm
                checkout([
                        $class: 'GitSCM',
                        branches: scm.branches,
                        doGenerateSubmoduleConfigurations: false,
                        extensions: [
                                [$class: 'LocalBranch', localBranch: '**'],
                                [$class: 'CheckoutOption', timeout: 1],
                                [$class: 'CloneOption', depth: 2, noTags: false, reference: '/var/lib/git/fibo', shallow: true, timeout: 1],
                                [$class: 'AuthorInChangelog'],
                                [$class: 'PruneStaleBranch'],
                                [$class: 'IgnoreNotifyCommit']
                        ],
                        submoduleCfg: [],
                        userRemoteConfigs: [
                                [credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877', url: 'https://github.com/edmcouncil/fibo.git']
                        ]
                ])
              }
              dir('LCC') { git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins' }
            }
            unstash 'output-ontology'
            sh "/publisher/publish.sh datadictionary"
          }
          post {
            success {
              stash name: 'output-datadictionary', includes: 'output/fibo/datadictionary/**'
            }
            always {
              archiveArtifacts artifacts: 'output/fibo/datadictionary/**/*.log', fingerprint: true
              script {
                slackNotifier(productName: 'DataDictionary', buildResult: currentBuild.currentResult)
              }
            }
          }
        }
//        stage("Build Reference") {
//          agent {
//            docker {
//              image env.ONTPUB_IMAGE
//              label 'docker'
//              alwaysPull true
//              args  "\
//                --network none \
//                --name ontology-publisher-${env.BUILD_NUMBER}-reference \
//              "
//            }
//          }
//          steps {
//            dir('input') {
//              dir('fibo') {
////          checkout scm
//                checkout([
//                        $class: 'GitSCM',
//                        branches: scm.branches,
//                        doGenerateSubmoduleConfigurations: false,
//                        extensions: [
//                                [$class: 'LocalBranch', localBranch: '**'],
//                                [$class: 'CheckoutOption', timeout: 1],
//                                [$class: 'CloneOption', depth: 2, noTags: false, reference: '/var/lib/git/fibo', shallow: true, timeout: 1],
//                                [$class: 'AuthorInChangelog'],
//                                [$class: 'PruneStaleBranch'],
//                                [$class: 'IgnoreNotifyCommit']
//                        ],
//                        submoduleCfg: [],
//                        userRemoteConfigs: [
//                                [credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877', url: 'https://github.com/edmcouncil/fibo.git']
//                        ]
//                ])
//              }
//              dir('LCC') { git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins' }
//            }
//            unstash 'output-ontology'
//            sh "/publisher/publish.sh reference"
//          }
//          post {
//            success {
//              stash name: 'output-reference', includes: 'output/fibo/reference/**'
//              archiveArtifacts artifacts: 'output/fibo/reference/**/*.pdf', fingerprint: true
//            }
//            always {
//              archiveArtifacts artifacts: 'output/fibo/reference/**/*.log', fingerprint: true
//              slackNotifier productName: 'Reference', buildResult: currentBuild.currentResult
//            }
//          }
//        }
      }
    } // end of stage 'Build Other Products'

    stage('Build Final Content') {
      agent {
        docker {
          image env.ONTPUB_IMAGE
          label 'docker'
          alwaysPull true
          args  "\
                --network none \
                --name ontology-publisher-${env.BUILD_NUMBER}-publish \
              "
        }
      }
      steps {
        dir('input') {
          dir('fibo') {
//          checkout scm
            checkout([
                    $class: 'GitSCM',
                    branches: scm.branches,
                    doGenerateSubmoduleConfigurations: false,
                    extensions: [
                            [$class: 'LocalBranch', localBranch: '**'],
                            [$class: 'CheckoutOption', timeout: 1],
                            [$class: 'CloneOption', depth: 2, noTags: false, reference: '/var/lib/git/fibo', shallow: true, timeout: 1],
                            [$class: 'AuthorInChangelog'],
                            [$class: 'PruneStaleBranch'],
                            [$class: 'IgnoreNotifyCommit']
                    ],
                    submoduleCfg: [],
                    userRemoteConfigs: [
                            [credentialsId: '50cac519-d41c-4765-8563-c43b7f55c877', url: 'https://github.com/edmcouncil/fibo.git']
                    ]
            ])
          }
          dir('LCC') { git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins' }
        }
        unstash 'output-ontology'
        unstash 'output-widoco'
        unstash 'output-glossary'
	      unstash 'output-fibopedia'
        unstash 'output-vocabulary'
        unstash 'output-datadictionary'
        unstash 'output-reference'
        //
        // Now after all the above is done, make sure we run the final
        // publish step which zips it all up into the target directory
        //
        sh "/publisher/publish.sh publish"
        //
        // Archive the artifacts generated by the publish command
        //
        dir('output') {
          stash([
            name: 'publish-script-output-stardog-node',
            includes: '**',
            excludes: '**/.git, **/.gitignore',
            useDefaultExcludes: true
          ])
        }
      }
    } // end of stage 'Build Final Content'

    //
    // Run the publish on the master jenkins agent by just copying all the generated artifacts right into the workspace
    // on master and let NGINX just serve it from there.
    //
    // This workspace will never be "wiped" so it contains all the older versions as well, wiping this workspace
    // will be bad because we would lose all previously published versions
    //
    stage('Publish') {

      agent {
        label 'master'
      }
      environment {
        NGINX_SPEC_ROOT = '/mnt/jenkins-disk/spec.edmcouncil.org'
      }

      steps {

        echo "Cleaning workspace:"
        sh 'rm -rf .* * || true'
        echo "Done cleaning"

        sh 'test -d ${NGINX_SPEC_ROOT}'
        sh 'pwd'

        echo 'Unstashing the output of the publish-script as it ran on the stardog node'
        unstash 'publish-script-output-stardog-node'
        //
        // TODO: The cleanups below should be done by the publish script
        //
        sh 'find . -name \'.git\' -exec rm -rf {} \\; || true'
        sh 'find . -name \'.gitignore\' -exec rm -f {} \\; || true'
        sh 'find . -type d -name node_modules -exec rm -rf {} \\; || true'
        sh 'find . -type d -name build -exec rm -rf {} \\; || true'
        sh 'find . -type d -name \'temp*\' -exec rm -rf {} \\; || true'
        sh 'find . -type f -name \'temp*\' -exec rm -f {} \\; || true'
        sh 'ls -al'

        echo "Copy all generated content to ${NGINX_SPEC_ROOT}:"
        sh 'ls -al ${NGINX_SPEC_ROOT}/'
        sh '''cp -vr . ${NGINX_SPEC_ROOT}/ > published-files.log 2>&1 || true
	        rc=$?
          if ((rc == 0)); then
	          echo "Successfully copied all files to destination, see published-files.log in the workspace"
	        else
	          echo "Some files may not have been copied"
	          tail published-files.log
	          exit 1
          fi
        '''
        archiveArtifacts artifacts: '**/*.log', fingerprint: true
        sh 'find . -name \'*.log\' -exec rm -f {} \\; || true'

        //setGitHubPullRequestStatus context: 'fibo-publish', message: '', state: 'SUCCESS'
      }
    } // end of stage "Publish"
  } // end of stages
} // end of pipeline

